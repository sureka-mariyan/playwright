"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReporterRuntime = void 0;
var _path = require("path");
var _model = require("../../model.js");
var _LifecycleState = require("./LifecycleState.js");
var _Notifier = require("./Notifier.js");
var _StaticAllureContextProvider = require("./context/StaticAllureContextProvider.js");
var _factory = require("./factory.js");
var _utils = require("./utils.js");
var _attachments = require("./utils/attachments.js");
var _loader = require("./writer/loader.js");
var _excluded = ["links", "attachments", "displayName", "parameters", "labels"],
  _excluded2 = ["status", "stage", "stop"];
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /* eslint max-lines: 0 */
class ReporterRuntime {
  constructor(_ref) {
    var _this = this;
    var {
      writer,
      listeners = [],
      links: _links = [],
      environmentInfo,
      categories,
      contextProvider = _StaticAllureContextProvider.StaticContextProvider.wrap(new _StaticAllureContextProvider.MutableAllureContextHolder())
    } = _ref;
    _defineProperty(this, "state", new _LifecycleState.LifecycleState());
    _defineProperty(this, "notifier", void 0);
    _defineProperty(this, "links", []);
    _defineProperty(this, "contextProvider", void 0);
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "categories", void 0);
    _defineProperty(this, "environmentInfo", void 0);
    _defineProperty(this, "hasScope", () => !!this.contextProvider.getScope());
    _defineProperty(this, "hasFixture", () => !!this.contextProvider.getFixture());
    _defineProperty(this, "hasTest", () => !!this.contextProvider.getTest());
    _defineProperty(this, "hasSteps", () => !!this.contextProvider.getStep());
    _defineProperty(this, "getCurrentTest", () => {
      var testUuid = this.contextProvider.getTest();
      return testUuid ? this.state.getTest(testUuid) : undefined;
    });
    _defineProperty(this, "getCurrentFixture", () => {
      var fixtureUuid = this.contextProvider.getFixture();
      return fixtureUuid ? this.state.getFixture(fixtureUuid) : undefined;
    });
    _defineProperty(this, "getCurrentStep", root => {
      var stepUuid = this.contextProvider.getStep(root);
      return stepUuid ? this.state.getStep(stepUuid) : undefined;
    });
    _defineProperty(this, "getCurrentExecutingItem", root => {
      var uuid = this.contextProvider.getExecutingItem(root);
      return uuid ? this.state.getExecutionItem(uuid) : undefined;
    });
    _defineProperty(this, "getCurrentScope", () => {
      var scopeUuid = this.contextProvider.getScope();
      return scopeUuid ? this.state.getScope(scopeUuid) : undefined;
    });
    /**
     * Creates a new scope. The scope is pushed into the context unless the `manual`
     * option is set to `true`.
     *
     * @param opts
     * @returns
     */
    _defineProperty(this, "startScope", function () {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return _this.startScopeWithUuid((0, _utils.randomUuid)(), opts);
    });
    _defineProperty(this, "updateScope", (updateFunc, uuid) => {
      var resolvedUuid = uuid !== null && uuid !== void 0 ? uuid : this.contextProvider.getScope();
      if (!resolvedUuid) {
        // eslint-disable-next-line no-console
        console.error("No current scope to update!");
        return;
      }
      var scope = this.state.getScope(resolvedUuid);
      if (!scope) {
        // eslint-disable-next-line no-console
        console.error("No scope ".concat(resolvedUuid, " to update!"));
        return;
      }
      updateFunc(scope);
    });
    /**
     * Removes a scope from the context. Use `writeScope` to emit its fixtures on disk then.
     *
     * If you just want to write the current stop, you may omit the call to this method and
     * call `writeScope` with no uuid.
     *
     * @param uuid The UUID of the scope. If not provided, the current scope will be stopped.
     *
     * @returns The UUID of the scope that has been stopped.
     */
    _defineProperty(this, "stopScope", uuid => {
      var resolvedUuid = uuid !== null && uuid !== void 0 ? uuid : this.contextProvider.getScope();
      if (!resolvedUuid) {
        // eslint-disable-next-line no-console
        console.error("No current scope to stop!");
        return;
      }
      this.contextProvider.removeScope(uuid);
      return resolvedUuid;
    });
    /**
     * Writes all fixtures of a scope on disk.
     *
     * @param uuid The UUID of the scope. If not provided, the current scope will
     * be written and removed from the context. Don't call `stopScope` in that case.
     */
    _defineProperty(this, "writeScope", uuid => {
      var resolvedUuid = uuid !== null && uuid !== void 0 ? uuid : this.stopScope();
      if (!resolvedUuid) {
        return;
      }
      var scope = this.state.getScope(resolvedUuid);
      if (!scope) {
        // eslint-disable-next-line no-console
        console.error("No scope ".concat(resolvedUuid, " to write!"));
        return;
      }
      this.writeAllFixturesOfScope(scope);
      this.removeScopeFromParent(scope);
      this.state.deleteScope(resolvedUuid);
    });
    /**
     * Creates a new fixture result and puts it in the context as the current one.
     *
     * Use the `scope` parameter to control the fixture's scope. Use `updateScope`
     * or `linkFixtures` to associate fixtures with tests that can't be linked
     * automatically.
     *
     * Use `stopFixture` once the fixture is completed.
     *
     * Use `writeScope` or `writeFixture` to emit fixtures on disk.
     *
     * @param type The type of the fixture. It's either `"before"` or `"after"`.
     * @param fixtureResult The fixture result data.
     * @param scope
     * @param dedicatedScope
     * @param tests
     * @returns The UUID of the new fixture.
     */
    _defineProperty(this, "startFixture", function (type, fixtureResult) {
      var {
        scope,
        dedicatedScope,
        tests
      } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      dedicatedScope = dedicatedScope || scope === null && !!tests;
      var scopeObj = _this.resolveScope(scope);
      if (scopeObj === undefined) {
        // eslint-disable-next-line no-console
        console.error("Can't resolve the scope for a new fixture");
        return;
      }
      var uuid = (0, _utils.randomUuid)();
      var wrappedFixture = _this.state.setFixtureResult(uuid, type, _objectSpread(_objectSpread({}, (0, _factory.createFixtureResult)()), {}, {
        start: Date.now()
      }, fixtureResult));
      if (dedicatedScope || tests && scopeObj === null) {
        _this.setUpFixtureDedicatedScope(wrappedFixture, tests, scopeObj);
      } else if (scopeObj !== null) {
        _this.linkFixtureToScope(wrappedFixture, scopeObj, tests);
      }
      _this.contextProvider.setFixture(uuid);
      return uuid;
    });
    _defineProperty(this, "updateFixture", (updateFunc, uuid) => {
      var resolvedUuid = uuid !== null && uuid !== void 0 ? uuid : this.contextProvider.getFixture();
      if (!resolvedUuid) {
        // eslint-disable-next-line no-console
        console.error("No current fixture to update!");
        return;
      }
      var fixture = this.state.getFixture(resolvedUuid);
      if (!fixture) {
        // eslint-disable-next-line no-console
        console.error("No fixture (".concat(resolvedUuid, ") to update!"));
        return;
      }
      updateFunc(fixture);
    });
    /**
     * Stops a fixture and removes it from the context. The fixture result will persist in
     * the storage until it's written on disk with `writeScope` or `writeFixture`.
     *
     * @returns The UUID of the stopped fixture.
     */
    _defineProperty(this, "stopFixture", function () {
      var {
        uuid,
        stop
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var resolvedUuid = uuid !== null && uuid !== void 0 ? uuid : _this.contextProvider.getFixture();
      if (!resolvedUuid) {
        // eslint-disable-next-line no-console
        console.error("No current fixture to stop!");
        return;
      }
      var fixture = _this.state.getFixture(resolvedUuid);
      if (!fixture) {
        // eslint-disable-next-line no-console
        console.error("No fixture (".concat(resolvedUuid, ") to stop!"));
        return;
      }
      _this.stopFixtureObj(fixture, uuid, stop);
      return resolvedUuid;
    });
    /**
     * Use to associate fixtures, scopes, and tests with each other.
     *
     * At least two arguments must be provided.
     */
    _defineProperty(this, "linkFixtures", _ref2 => {
      var {
        fixtures = [],
        scope,
        tests = []
      } = _ref2;
      var wrappedFixtures = fixtures.map(f => {
        var obj = this.state.getWrappedFixture(f);
        if (obj === undefined) {
          // eslint-disable-next-line no-console
          console.error("No fixture (".concat(f, ") to link!"));
        }
        return obj;
      }).filter(f => f);
      var scopeObj = scope ? this.state.getScope(scope) : null;
      if (scopeObj === undefined) {
        // eslint-disable-next-line no-console
        console.error("No scope (".concat(scope, ") to link!"));
        return;
      }
      if (wrappedFixtures.length && scopeObj) {
        this.linkFixturesToScope(wrappedFixtures, scopeObj, tests);
        return;
      }
      if (wrappedFixtures.length && tests.length) {
        for (var fixture of wrappedFixtures) {
          if (fixture.scope) {
            this.linkTestsToScope(fixture.scope, tests);
          } else {
            this.setUpFixtureDedicatedScope(fixture, tests);
          }
        }
        return;
      }
      if (scopeObj && tests) {
        this.linkTestsToScope(scopeObj, tests);
        return;
      }

      // eslint-disable-next-line no-console
      console.error("Provide at least two arguments to link!");
    });
    /**
     * Emits a fixture on disk. Calls `stopFixture` prior to that in case the fixture
     * hasn't been stopped yet. Use this method if you want to manage fixtures manually.
     * Otherwise, use `writeScope`.
     *
     * If called without parameters, implicitly calls `stopFixture`. Make sure you don't call
     * `stopFixture` by yourself in that case.
     *
     * The method has no effect if the fixture isn't associated with at least one test.
     *
     * @param uuid The UUID of the fixture. If not provided, the current fixture will
     * be stopped and emitted. Don't call `stopFixture` in that case.
     */
    _defineProperty(this, "writeFixture", uuid => {
      var resolvedUuid = uuid !== null && uuid !== void 0 ? uuid : this.stopFixture();
      if (!resolvedUuid) {
        // eslint-disable-next-line no-console
        console.error("Unable to stop the current fixture before write!");
        return;
      }
      var wrappedFixture = this.state.getWrappedFixture(resolvedUuid);
      if (!wrappedFixture) {
        // eslint-disable-next-line no-console
        console.error("No fixture (".concat(resolvedUuid, ") to write!"));
        return;
      }
      var fixture = wrappedFixture.value;
      if (fixture.stage !== _model.Stage.FINISHED) {
        this.stopFixtureObj(wrappedFixture.value, resolvedUuid);
      }
      var {
        scope
      } = wrappedFixture;
      if (scope) {
        this.writeContainer(scope.tests, wrappedFixture);
        this.removeFixtureFromScope(scope, wrappedFixture);
      }
      this.state.deleteFixtureResult(resolvedUuid);
    });
    _defineProperty(this, "startTest", function (result) {
      var {
        scope,
        dedicatedScope
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var stateObject = _this.createTestResult(result);
      var uuid = stateObject.uuid;
      _this.notifier.beforeTestResultStart(stateObject);
      var resolvedScope = dedicatedScope ? _this.startScopeWithUuid(uuid, {
        manual: scope !== undefined,
        parent: scope !== null && scope !== void 0 ? scope : undefined
      }) : scope !== null && scope !== void 0 ? scope : _this.contextProvider.getScope();
      if (resolvedScope) {
        _this.introduceTestIntoScopes(uuid, resolvedScope);
      }
      _this.state.setTestResult(uuid, stateObject);
      _this.contextProvider.setTest(uuid);
      _this.notifier.afterTestResultStart(stateObject);
      return uuid;
    });
    /**
     * Updates test result by uuid
     * @example
     * ```ts
     * runtime.update(uuid, (result) => {
     *   // change the result directly, you don't need to return anything
     *   result.name = "foo";
     * });
     * ```
     * @param updateFunc - a function that updates the test result; the result is passed as a single argument and should be mutated to apply the changes
     * @param uuid - test result uuid
     */
    _defineProperty(this, "updateTest", (updateFunc, uuid) => {
      var resolvedUuid = uuid !== null && uuid !== void 0 ? uuid : this.contextProvider.getTest();
      if (!resolvedUuid) {
        // eslint-disable-next-line no-console
        console.error("No current test to update!");
        return;
      }
      var targetResult = this.state.getTest(resolvedUuid);
      if (!targetResult) {
        // eslint-disable-next-line no-console
        console.error("No test (".concat(resolvedUuid, ") to update!"));
        return;
      }
      this.notifier.beforeTestResultUpdate(targetResult);
      updateFunc(targetResult);
      this.notifier.afterTestResultUpdate(targetResult);
    });
    _defineProperty(this, "stopTest", function () {
      var _targetResult$testCas, _targetResult$history;
      var {
        uuid,
        stop
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var resolvedUuid = uuid !== null && uuid !== void 0 ? uuid : _this.contextProvider.getTest();
      if (!resolvedUuid) {
        // eslint-disable-next-line no-console
        console.error("No current test to stop!");
        return;
      }
      var targetResult = _this.state.getTest(resolvedUuid);
      if (!targetResult) {
        // eslint-disable-next-line no-console
        console.error("No test (".concat(resolvedUuid, ") to stop!"));
        return;
      }
      _this.notifier.beforeTestResultStop(targetResult);
      (_targetResult$testCas = targetResult.testCaseId) !== null && _targetResult$testCas !== void 0 ? _targetResult$testCas : targetResult.testCaseId = (0, _utils.getTestResultTestCaseId)(targetResult);
      (_targetResult$history = targetResult.historyId) !== null && _targetResult$history !== void 0 ? _targetResult$history : targetResult.historyId = (0, _utils.getTestResultHistoryId)(targetResult);
      targetResult.stop = stop || Date.now();
      _this.notifier.afterTestResultStop(targetResult);
    });
    /**
     * Writes a test result on disk and removes it from the storage and the context.
     * @param uuid The UUID of the test. If not set, the current test result is written.
     */
    _defineProperty(this, "writeTest", uuid => {
      var resolvedUuid = uuid !== null && uuid !== void 0 ? uuid : this.contextProvider.getTest();
      if (!resolvedUuid) {
        // eslint-disable-next-line no-console
        console.error("No current test to write!");
        return;
      }
      var testResult = this.state.testResults.get(resolvedUuid);
      if (!testResult) {
        // eslint-disable-next-line no-console
        console.error("No test (".concat(resolvedUuid, ") to write!"));
        return;
      }
      this.notifier.beforeTestResultWrite(testResult);
      this.writer.writeResult(testResult);
      this.contextProvider.removeTest(uuid);
      this.state.deleteTestResult(resolvedUuid);
      var currentScope = this.contextProvider.getScope();
      if (currentScope === resolvedUuid) {
        // Writes the scope introduced into the context by `startTest` with
        // `dedicatedScope` set to `true`.
        this.writeScope();
      }
      this.notifier.afterTestResultWrite(testResult);
    });
    /**
     * Starts a new step and pushes it into the context.
     *
     * @param result Data to be put into the step result object.
     * @param uuid The UUID of a test or fixture to attach the step to. If not set, the UUID of the current fixture is used.
     * If no fixture is running, the UUID of the current test is used.
     *
     * @returns The UUID of the step.
     */
    _defineProperty(this, "startStep", (result, uuid) => {
      var parentUuid = this.contextProvider.getExecutingItem(uuid);
      if (!parentUuid) {
        // eslint-disable-next-line no-console
        console.error("No current step, fixture, or test to start a new step!");
        return;
      }
      var parent = this.state.getExecutionItem(parentUuid);
      if (!parent) {
        // eslint-disable-next-line no-console
        console.error("No execution item (".concat(parentUuid, ") to start a step!"));
        return;
      }
      return this.addStepToItem(result, uuid, parent);
    });
    _defineProperty(this, "updateStep", (updateFunc, uuid) => {
      var stepUuid = this.contextProvider.getStep(uuid);
      if (!stepUuid) {
        this.logMissingStepRoot(uuid, "update");
        return;
      }
      var step = this.state.getStep(stepUuid);
      if (!step) {
        // eslint-disable-next-line no-console
        console.error("No step ".concat(stepUuid, " to update!"));
        return;
      }
      updateFunc(step);
    });
    _defineProperty(this, "stopStep", function () {
      var {
        uuid,
        stop
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var stepUuid = _this.contextProvider.getStep(uuid);
      if (!stepUuid) {
        _this.logMissingStepRoot(uuid, "stop");
        return;
      }
      var step = _this.state.getStep(stepUuid);
      if (!step) {
        // eslint-disable-next-line no-console
        console.error("No step ".concat(stepUuid, " to stop!"));
        return;
      }
      _this.notifier.beforeStepStop(step);
      step.stop = stop !== null && stop !== void 0 ? stop : Date.now();
      step.stage = _model.Stage.FINISHED;
      _this.state.deleteStepResult(stepUuid);
      _this.contextProvider.removeStep(uuid);
      _this.notifier.afterStepStop(step);
    });
    _defineProperty(this, "writeAttachment", (attachmentName, attachmentContent, options, uuid) => {
      var target = this.getCurrentExecutingItem(uuid);
      if (!target) {
        if (uuid) {
          // eslint-disable-next-line no-console
          console.error("No test or fixture ".concat(uuid, " to attach!"));
        } else {
          // eslint-disable-next-line no-console
          console.error("No current test or fixture to attach!");
        }
        return;
      }
      this.writeAttachmentForItem(attachmentName, attachmentContent, options, target);
    });
    _defineProperty(this, "writeAttachmentFromPath", (attachmentName, attachmentPath, options, uuid) => {
      var target = this.getCurrentExecutingItem(uuid);
      if (!target) {
        if (uuid) {
          // eslint-disable-next-line no-console
          console.error("No test or fixture ".concat(uuid, " to attach!"));
        } else {
          // eslint-disable-next-line no-console
          console.error("No current test or fixture to attach!");
        }
        return;
      }
      this.writeAttachmentForItem(attachmentName, attachmentPath, options, target);
    });
    _defineProperty(this, "writeEnvironmentInfo", () => {
      if (!this.environmentInfo) {
        return;
      }
      this.writer.writeEnvironmentInfo(this.environmentInfo);
    });
    _defineProperty(this, "writeCategoriesDefinitions", () => {
      if (!this.categories) {
        return;
      }
      var serializedCategories = this.categories.map(c => {
        if (c.messageRegex instanceof RegExp) {
          c.messageRegex = c.messageRegex.source;
        }
        if (c.traceRegex instanceof RegExp) {
          c.traceRegex = c.traceRegex.source;
        }
        return c;
      });
      this.writer.writeCategoriesDefinitions(serializedCategories);
    });
    _defineProperty(this, "applyRuntimeMessages", function () {
      var _ref3;
      var messages = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var {
        testUuid,
        fixtureUuid,
        customHandler
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var resolvedTestUuid = testUuid !== null && testUuid !== void 0 ? testUuid : _this.contextProvider.getTest();
      var resolvedFixtureUuid = fixtureUuid !== null && fixtureUuid !== void 0 ? fixtureUuid : _this.contextProvider.getFixture();
      var resolvedRootUuid = (_ref3 = resolvedFixtureUuid !== null && resolvedFixtureUuid !== void 0 ? resolvedFixtureUuid : resolvedTestUuid) !== null && _ref3 !== void 0 ? _ref3 : _this.contextProvider.getStepRoot();
      if (!resolvedRootUuid) {
        // eslint-disable-next-line no-console
        console.error("No current fixture or test to apply runtime messages to!");
        return;
      }
      var fixture = resolvedFixtureUuid ? _this.state.getFixture(resolvedFixtureUuid) : undefined;
      var test = resolvedTestUuid ? _this.state.getTest(resolvedTestUuid) : undefined;
      var root = fixture !== null && fixture !== void 0 ? fixture : test;
      if (!root) {
        // eslint-disable-next-line no-console
        console.error("No fixture or test (".concat(resolvedRootUuid, ") to apply runtime messages to!"));
        return;
      }
      var targets = {
        fixtureUuid: resolvedFixtureUuid !== null && resolvedFixtureUuid !== void 0 ? resolvedFixtureUuid : undefined,
        fixture,
        testUuid: resolvedTestUuid !== null && resolvedTestUuid !== void 0 ? resolvedTestUuid : undefined,
        test,
        rootUuid: resolvedRootUuid,
        root
      };
      for (var message of messages) {
        var step = _this.getCurrentStep(resolvedRootUuid);
        targets.step = step;
        var unhandledMessage = _this.handleBuiltInMessage(message, targets);
        if (unhandledMessage && customHandler) {
          customHandler(unhandledMessage, fixture, test, step);
        }
      }
    });
    _defineProperty(this, "handleBuiltInMessage", (message, targets) => {
      switch (message.type) {
        case "metadata":
          this.handleMetadataMessage(message, targets);
          return;
        case "step_start":
          this.handleStepStartMessage(message, targets);
          return;
        case "step_metadata":
          this.handleStepMetadataMessage(message, targets);
          return;
        case "step_stop":
          this.handleStepStopMessage(message, targets);
          return;
        case "attachment_content":
          this.handleAttachmentContentMessage(message, targets);
          return;
        case "attachment_path":
          this.handleAttachmentPathMessage(message, targets);
          return;
        default:
          return message;
      }
    });
    _defineProperty(this, "handleMetadataMessage", (message, _ref4) => {
      var {
        test,
        root,
        step
      } = _ref4;
      var _message$data = message.data,
        {
          links = [],
          attachments = [],
          displayName,
          parameters = [],
          labels = []
        } = _message$data,
        rest = _objectWithoutProperties(_message$data, _excluded);
      var formattedLinks = this.formatLinks(links);
      if (displayName) {
        root.name = displayName;
      }
      if (test) {
        test.links = test.links.concat(formattedLinks);
        test.labels = test.labels.concat(labels);
        test.parameters = test.parameters.concat(parameters);
        Object.assign(test, rest);
      }
      var attachmentTarget = step || root;
      attachmentTarget.attachments = attachmentTarget.attachments.concat(attachments);
    });
    _defineProperty(this, "handleStepStartMessage", (message, _ref5) => {
      var {
        rootUuid,
        root,
        step
      } = _ref5;
      return this.addStepToItem(_objectSpread({}, message.data), rootUuid, step !== null && step !== void 0 ? step : root);
    });
    _defineProperty(this, "handleStepMetadataMessage", (message, _ref6) => {
      var {
        rootUuid,
        step
      } = _ref6;
      if (!step) {
        // eslint-disable-next-line no-console
        console.error("No current step of ".concat(rootUuid, " to apply the metadata"));
        return;
      }
      var {
        name,
        parameters
      } = message.data;
      if (name) {
        step.name = name;
      }
      if (parameters !== null && parameters !== void 0 && parameters.length) {
        step.parameters = step.parameters.concat(parameters);
      }
    });
    _defineProperty(this, "handleStepStopMessage", (message, _ref7) => {
      var {
        rootUuid,
        step
      } = _ref7;
      if (!step) {
        // eslint-disable-next-line no-console
        console.error("No current step of ".concat(rootUuid, " to stop"));
        return;
      }
      var _message$data2 = message.data,
        {
          status,
          stage,
          stop
        } = _message$data2,
        rest = _objectWithoutProperties(_message$data2, _excluded2);

      // we should not override the status and stage if they are already set
      if (step.status === undefined) {
        step.status = status;
      }
      if (step.stage === undefined) {
        step.stage = stage;
      }
      Object.assign(step, rest);
      this.stopStep({
        uuid: rootUuid,
        stop
      });
    });
    _defineProperty(this, "handleAttachmentContentMessage", (message, _ref8) => {
      var {
        root,
        step
      } = _ref8;
      var item = step !== null && step !== void 0 ? step : root;
      var {
        name,
        content,
        encoding,
        contentType,
        fileExtension,
        wrapInStep
      } = message.data;
      this.writeAttachmentForItem(name, Buffer.from(content, encoding), {
        contentType,
        fileExtension
      }, item, wrapInStep);
    });
    _defineProperty(this, "handleAttachmentPathMessage", (message, _ref9) => {
      var {
        root,
        step
      } = _ref9;
      var item = step !== null && step !== void 0 ? step : root;
      var {
        name,
        path,
        contentType,
        fileExtension,
        wrapInStep
      } = message.data;
      this.writeAttachmentForItem(name, path, {
        contentType,
        fileExtension
      }, item, wrapInStep);
    });
    _defineProperty(this, "writeAttachmentForItem", function (attachmentName, attachmentContentOrPath, options, item) {
      var _options$fileExtensio;
      var wrapInStepAttachment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var isPath = typeof attachmentContentOrPath === "string";
      var fileExtension = (_options$fileExtensio = options.fileExtension) !== null && _options$fileExtensio !== void 0 ? _options$fileExtensio : isPath ? (0, _path.extname)(attachmentContentOrPath) : undefined;
      var attachmentFileName = (0, _attachments.buildAttachmentFileName)({
        contentType: options.contentType,
        fileExtension
      });
      if (isPath) {
        _this.writer.writeAttachmentFromPath(attachmentFileName, attachmentContentOrPath);
      } else {
        _this.writer.writeAttachment(attachmentFileName, attachmentContentOrPath);
      }
      var attachment = {
        name: attachmentName,
        source: attachmentFileName,
        type: options.contentType
      };
      if (wrapInStepAttachment) {
        item.steps.push({
          name: attachmentName,
          attachments: [attachment]
        });
      } else {
        item.attachments.push(attachment);
      }
    });
    _defineProperty(this, "startScopeWithUuid", function (uuid) {
      var {
        manual,
        parent
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var newScope = _this.state.setScope(uuid);
      if (!manual) {
        var _this$contextProvider;
        parent = (_this$contextProvider = _this.contextProvider.getScope()) !== null && _this$contextProvider !== void 0 ? _this$contextProvider : undefined;
        _this.contextProvider.addScope(uuid);
      }
      if (parent) {
        var parentScope = _this.state.getScope(parent);
        if (parentScope) {
          _this.linkScopes(parentScope, newScope);
        }
      }
      return uuid;
    });
    _defineProperty(this, "resolveScope", scopeUuid => {
      var _scopeUuid;
      if (scopeUuid === null) {
        return null;
      }
      scopeUuid = (_scopeUuid = scopeUuid) !== null && _scopeUuid !== void 0 ? _scopeUuid : this.contextProvider.getScope();
      return scopeUuid ? this.state.getScope(scopeUuid) : null;
    });
    _defineProperty(this, "removeScopeFromParent", scope => {
      var _scope$parent;
      var {
        subScopes
      } = (_scope$parent = scope.parent) !== null && _scope$parent !== void 0 ? _scope$parent : {};
      if (subScopes) {
        var scopeIndex = subScopes.indexOf(scope);
        if (scopeIndex !== -1) {
          subScopes.splice(scopeIndex, 1);
        }
      }
    });
    _defineProperty(this, "removeFixtureFromScope", (_ref10, wrappedFixture) => {
      var {
        fixtures
      } = _ref10;
      var fixtureIndex = fixtures.indexOf(wrappedFixture);
      if (fixtureIndex !== -1) {
        fixtures.splice(fixtureIndex, 1);
      }
    });
    _defineProperty(this, "setUpFixtureDedicatedScope", (wrappedFixture, tests, parentScope) => {
      var scope = this.state.setScope(wrappedFixture.uuid, {
        fixtures: [wrappedFixture],
        tests: [...(tests !== null && tests !== void 0 ? tests : [])]
      });
      wrappedFixture.scope = scope;
      if (parentScope) {
        this.linkScopes(parentScope, scope);
      }
    });
    _defineProperty(this, "linkScopes", (parent, child) => {
      child.parent = parent;
      parent.subScopes.push(child);
    });
    _defineProperty(this, "linkFixturesToScope", (wrappedFixtures, scope, extraTests) => {
      for (var fixture of wrappedFixtures) {
        this.linkFixtureToScope(fixture, scope, extraTests);
      }
    });
    _defineProperty(this, "linkFixtureToScope", (wrappedFixture, scope, extraTests) => {
      if (wrappedFixture.scope) {
        var fixtureIndex = wrappedFixture.scope.fixtures.indexOf(wrappedFixture);
        if (fixtureIndex !== -1) {
          wrappedFixture.scope.fixtures.splice(fixtureIndex, 1);
        }
      }
      wrappedFixture.scope = scope;
      scope.fixtures.push(wrappedFixture);
      if (extraTests) {
        this.linkTestsToScope(scope, extraTests);
      }
    });
    _defineProperty(this, "stopFixtureObj", (fixture, uuid, stop) => {
      fixture.stop = stop !== null && stop !== void 0 ? stop : Date.now();
      fixture.stage = _model.Stage.FINISHED;
      this.contextProvider.removeFixture(uuid);
    });
    _defineProperty(this, "writeAllFixturesOfScope", root => {
      var stack = [root];
      for (var scope = stack.pop(); scope; scope = stack.pop()) {
        this.writeFixturesOfScope(scope);
        this.state.deleteScope(scope.uuid);
      }
    });
    _defineProperty(this, "writeFixturesOfScope", _ref11 => {
      var {
        fixtures,
        tests
      } = _ref11;
      var writtenFixtures = new Set();
      if (tests.length) {
        for (var wrappedFixture of fixtures) {
          if (!writtenFixtures.has(wrappedFixture.uuid)) {
            this.writeContainer(tests, wrappedFixture);
            this.state.deleteFixtureResult(wrappedFixture.uuid);
            writtenFixtures.add(wrappedFixture.uuid);
          }
        }
      }
    });
    _defineProperty(this, "writeContainer", (tests, wrappedFixture) => {
      var fixture = wrappedFixture.value;
      var befores = wrappedFixture.type === "before" ? [wrappedFixture.value] : [];
      var afters = wrappedFixture.type === "after" ? [wrappedFixture.value] : [];
      this.writer.writeGroup({
        uuid: (0, _utils.randomUuid)(),
        name: fixture.name,
        children: [...new Set(tests)],
        befores,
        afters
      });
    });
    _defineProperty(this, "addStepToItem", (data, rootUuid, parent) => {
      var stepResult = _objectSpread(_objectSpread({}, (0, _factory.createStepResult)()), {}, {
        start: Date.now()
      }, data);
      parent.steps.push(stepResult);
      var stepUuid = (0, _utils.randomUuid)();
      this.state.setStepResult(stepUuid, stepResult);
      this.contextProvider.addStep(stepUuid, rootUuid);
      return stepUuid;
    });
    _defineProperty(this, "logMissingStepRoot", (uuid, op) => {
      if (uuid) {
        // eslint-disable-next-line no-console
        console.error("No test or fixture of (".concat(uuid, ") to ").concat(op, " the step!"));
      } else {
        // eslint-disable-next-line no-console
        console.error("No current step to ".concat(op, "!"));
      }
    });
    _defineProperty(this, "formatLinks", links => {
      if (!this.links.length) {
        return links;
      }
      return links.map(link => {
        var _this$links, _this$links$find;
        // TODO:
        // @ts-ignore
        var matcher = (_this$links = this.links) === null || _this$links === void 0 || (_this$links$find = _this$links.find) === null || _this$links$find === void 0 ? void 0 : _this$links$find.call(_this$links, _ref12 => {
          var {
            type
          } = _ref12;
          return type === link.type;
        });

        // TODO:
        if (!matcher || link.url.startsWith("http")) {
          return link;
        }
        var url = matcher.urlTemplate.replace("%s", link.url);

        // we shouldn't need to reassign already assigned name
        if (link.name || !matcher.nameTemplate) {
          return _objectSpread(_objectSpread({}, link), {}, {
            url
          });
        }
        var name = matcher.nameTemplate.replace("%s", link.url);
        return _objectSpread(_objectSpread({}, link), {}, {
          name,
          url
        });
      });
    });
    _defineProperty(this, "introduceTestIntoScopes", (testUuid, scopeUuid) => {
      var scope = this.state.getScope(scopeUuid);
      if (!scope) {
        // eslint-disable-next-line no-console
        console.error("No scope ".concat(scopeUuid, " to introduce the test into"));
        return;
      }
      this.linkTestsToScope(scope, [testUuid]);
    });
    _defineProperty(this, "linkTestsToScope", (scope, testUuids) => {
      for (var curScope = scope; curScope; curScope = curScope.parent) {
        curScope.tests.splice(curScope.tests.length, 0, ...testUuids);
      }
    });
    this.writer = (0, _loader.resolveWriter)(writer);
    this.notifier = new _Notifier.Notifier({
      listeners
    });
    this.links = _links;
    this.categories = categories;
    this.environmentInfo = environmentInfo;
    this.contextProvider = contextProvider;
  }
  createTestResult(result) {
    var uuid = (0, _utils.randomUuid)();
    return _objectSpread(_objectSpread({}, (0, _factory.createTestResult)(uuid)), {}, {
      start: Date.now()
    }, (0, _utils.deepClone)(result));
  }
}
exports.ReporterRuntime = ReporterRuntime;
//# sourceMappingURL=ReporterRuntime.js.map