var _StaticContextProvider;
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import { AllureContextProviderBase } from "./AllureContextProviderBase.js";
/**
 * Allure context that stores its data in mutable class fields.
 * Unsafe from the cuncurrency standpoint.
 */
export class MutableAllureContext {
  constructor() {
    _defineProperty(this, "scopeStack", []);
    _defineProperty(this, "currentFixture", null);
    _defineProperty(this, "currentTest", null);
    _defineProperty(this, "stepStacks", new Map());
    _defineProperty(this, "getScope", () => MutableAllureContext.last(this.scopeStack));
    _defineProperty(this, "getFixture", () => this.currentFixture);
    _defineProperty(this, "getTest", () => this.currentTest);
    _defineProperty(this, "getStep", scope => MutableAllureContext.last(this.stepStacks.get(scope)));
  }
}

/**
 * Implements transitioning between context values by mutating the context
 * object.
 * Unsafe from the cuncurrency standpoint.
 */
_defineProperty(MutableAllureContext, "last", arr => {
  var _arr;
  return (_arr = arr === null || arr === void 0 ? void 0 : arr[arr.length - 1]) !== null && _arr !== void 0 ? _arr : null;
});
export class MutableAllureContextHolder {
  constructor() {
    _defineProperty(this, "context", new MutableAllureContext());
    _defineProperty(this, "get", () => this.context);
    _defineProperty(this, "addScope", uuid => {
      this.context.scopeStack.push(uuid);
    });
    _defineProperty(this, "removeScope", () => {
      this.context.scopeStack.pop();
    });
    _defineProperty(this, "removeScopeByUuid", uuid => MutableAllureContextHolder.removeAllOccurrences(this.context.scopeStack, uuid));
    _defineProperty(this, "setFixture", uuid => {
      this.context.currentFixture = uuid;
    });
    _defineProperty(this, "removeFixture", () => {
      this.context.currentFixture = null;
    });
    _defineProperty(this, "setTest", uuid => {
      this.context.currentTest = uuid;
    });
    _defineProperty(this, "removeTest", () => {
      this.context.currentTest = null;
    });
    _defineProperty(this, "addStep", (scope, uuid) => {
      var steps = this.context.stepStacks.get(scope);
      if (steps) {
        steps.push(uuid);
      } else {
        this.context.stepStacks.set(scope, [uuid]);
      }
    });
    _defineProperty(this, "removeStep", scope => {
      var steps = this.context.stepStacks.get(scope);
      if (steps) {
        steps.pop();
        if (!steps.length) {
          this.context.stepStacks.delete(scope);
        }
      }
    });
    _defineProperty(this, "removeStepByUuid", (scope, uuid) => {
      var steps = this.context.stepStacks.get(scope);
      if (steps) {
        MutableAllureContextHolder.removeAllOccurrences(steps, uuid);
        if (!steps.length) {
          this.context.stepStacks.delete(scope);
        }
      }
    });
  }
  static removeAllOccurrences(arr, val) {
    for (var i = arr.indexOf(val); i !== -1; i = arr.indexOf(val, i)) {
      arr.splice(i, 1);
    }
  }
}

/**
 * Stores the context in a class field. That's a simple but not async-safe way of
 * manipulating the context.
 */
export class StaticContextProvider extends AllureContextProviderBase {
  constructor(holderSingleton) {
    super();
    this.holderSingleton = holderSingleton;
    _defineProperty(this, "load", () => this.holderSingleton);
    /* The changes are already persisted in the holder singleton. */
    _defineProperty(this, "store", holder => {
      if (!Object.is(holder, this.holderSingleton)) {
        throw new Error("The static context holder can'be replaced with another one.");
      }
    });
  }
}
_StaticContextProvider = StaticContextProvider;
/**
 * Wraps a context holder singleton in the static context provider.
 * @param holderSingleton The singleton to wrap.
 */
// eslint-disable-next-line @typescript-eslint/no-shadow
_defineProperty(StaticContextProvider, "wrap", holderSingleton => new _StaticContextProvider(holderSingleton));
//# sourceMappingURL=StaticAllureContextProvider.js.map