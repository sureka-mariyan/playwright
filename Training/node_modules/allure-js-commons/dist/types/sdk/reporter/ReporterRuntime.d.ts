/// <reference types="node" />
import type { AttachmentOptions, FixtureResult, StepResult, TestResult } from "../../model.js";
import type { Category, EnvironmentInfo, Messages, RuntimeMessage } from "../types.js";
import type { Config, FixtureType, TestScope, Writer } from "./types.js";
type StartScopeOpts = {
    /**
     * If set to `true`, a manual scope will be created. A manual scope doesn't affect
     * the context. Therefore, tests and fixtures aren't linked to it
     * automatically.
     *
     * Use `linkFixtures`, `updateScope`, or test and fixture start options to fill
     * such scope with tests and fixtures.
     */
    manual?: boolean;
    /**
     * If set to the UUID of an existing scope, the new scope will be created as its
     * sub-scope.
     *
     * Has an effect only if `manual` is `true`.
     */
    parent?: string;
};
type StartFixtureOpts = {
    /**
     * The UUID of the scope that should be associated with the fixture. Defaults to the current
     * scope of the context.
     *
     * If set to `null`, the fixture won't be attached to any scope (except the
     * dedicated one in case `dedicatedScope` is `true`).
     */
    scope?: string | null;
    /**
     * If set to `true`, an extra scope will be created to hold the fixture result.
     * The scope gets the same UUID as the fixture result and isn't pushed into
     * the context.
     *
     * The scope denoted by the `scope` option will serve as the parent.
     */
    dedicatedScope?: boolean;
    /**
     * The UUIDs of tests affected by the fixture. Those tests will be associated
     * with the fixture's scope.
     *
     * If the `scope` option is set to `null`, implicitly sets `dedicatedScope` to `true`.
     */
    tests?: string[];
};
type StartTestOpts = {
    /**
     * The UUID of a scope the test should be associated with. Defaults to the current one.
     *
     * If set to `null`, the test won't be associated with any scope (except the
     * dedicated one in case the `dedicatedScope` option is `true`).
     */
    scope?: string | null;
    /**
     * If set to `true`, an extra scope will be created with the same UUID as the
     * test result. The test will be attached to that scope.
     *
     * The scope denoted by the `scope` option will serve as the parent.
     */
    dedicatedScope?: boolean;
};
type StopOpts = {
    /**
     * The test's or fixture's stop time. Defaults to `Date.now()`.
     */
    stop?: number;
    /**
     * The UUID of a test or fixture to stop.
     */
    uuid?: string;
};
type LinkFixturesOpts = {
    /**
     * The UUIDs of fixtures to associate with the scope or tests.
     */
    fixtures?: readonly string[];
    /**
     * The UUID of a scope to associate with the fixture or tests.
     */
    scope?: string;
    /**
     * The UUIDs of tests to associate with the fixture or scope.
     */
    tests?: readonly string[];
};
type ApplyMessagesOpts<T> = {
    fixtureUuid?: string;
    testUuid?: string;
    customHandler?: (message: Exclude<Messages<T>, RuntimeMessage>, fixture?: FixtureResult, test?: TestResult, step?: StepResult) => void | Promise<void>;
};
export declare class ReporterRuntime {
    private readonly state;
    private notifier;
    private links;
    private contextProvider;
    writer: Writer;
    categories?: Category[];
    environmentInfo?: EnvironmentInfo;
    constructor({ writer, listeners, links, environmentInfo, categories, contextProvider, }: Config);
    hasScope: () => boolean;
    hasFixture: () => boolean;
    hasTest: () => boolean;
    hasSteps: () => boolean;
    getCurrentTest: () => TestResult | undefined;
    getCurrentFixture: () => FixtureResult | undefined;
    getCurrentStep: (root?: string) => StepResult | undefined;
    getCurrentExecutingItem: (root?: string) => FixtureResult | TestResult | StepResult | undefined;
    getCurrentScope: () => TestScope | undefined;
    /**
     * Creates a new scope. The scope is pushed into the context unless the `manual`
     * option is set to `true`.
     *
     * @param opts
     * @returns
     */
    startScope: (opts?: StartScopeOpts) => string;
    updateScope: (updateFunc: (scope: TestScope) => void, uuid?: string) => void;
    /**
     * Removes a scope from the context. Use `writeScope` to emit its fixtures on disk then.
     *
     * If you just want to write the current stop, you may omit the call to this method and
     * call `writeScope` with no uuid.
     *
     * @param uuid The UUID of the scope. If not provided, the current scope will be stopped.
     *
     * @returns The UUID of the scope that has been stopped.
     */
    stopScope: (uuid?: string) => string | undefined;
    /**
     * Writes all fixtures of a scope on disk.
     *
     * @param uuid The UUID of the scope. If not provided, the current scope will
     * be written and removed from the context. Don't call `stopScope` in that case.
     */
    writeScope: (uuid?: string) => void;
    /**
     * Creates a new fixture result and puts it in the context as the current one.
     *
     * Use the `scope` parameter to control the fixture's scope. Use `updateScope`
     * or `linkFixtures` to associate fixtures with tests that can't be linked
     * automatically.
     *
     * Use `stopFixture` once the fixture is completed.
     *
     * Use `writeScope` or `writeFixture` to emit fixtures on disk.
     *
     * @param type The type of the fixture. It's either `"before"` or `"after"`.
     * @param fixtureResult The fixture result data.
     * @param scope
     * @param dedicatedScope
     * @param tests
     * @returns The UUID of the new fixture.
     */
    startFixture: (type: FixtureType, fixtureResult: Partial<FixtureResult>, { scope, dedicatedScope, tests }?: StartFixtureOpts) => `${string}-${string}-${string}-${string}-${string}` | undefined;
    updateFixture: (updateFunc: (result: FixtureResult) => void, uuid?: string) => void;
    /**
     * Stops a fixture and removes it from the context. The fixture result will persist in
     * the storage until it's written on disk with `writeScope` or `writeFixture`.
     *
     * @returns The UUID of the stopped fixture.
     */
    stopFixture: ({ uuid, stop }?: StopOpts) => string | undefined;
    /**
     * Use to associate fixtures, scopes, and tests with each other.
     *
     * At least two arguments must be provided.
     */
    linkFixtures: ({ fixtures, scope, tests }: LinkFixturesOpts) => void;
    /**
     * Emits a fixture on disk. Calls `stopFixture` prior to that in case the fixture
     * hasn't been stopped yet. Use this method if you want to manage fixtures manually.
     * Otherwise, use `writeScope`.
     *
     * If called without parameters, implicitly calls `stopFixture`. Make sure you don't call
     * `stopFixture` by yourself in that case.
     *
     * The method has no effect if the fixture isn't associated with at least one test.
     *
     * @param uuid The UUID of the fixture. If not provided, the current fixture will
     * be stopped and emitted. Don't call `stopFixture` in that case.
     */
    writeFixture: (uuid?: string) => void;
    startTest: (result: Partial<TestResult>, { scope, dedicatedScope }?: StartTestOpts) => string;
    /**
     * Updates test result by uuid
     * @example
     * ```ts
     * runtime.update(uuid, (result) => {
     *   // change the result directly, you don't need to return anything
     *   result.name = "foo";
     * });
     * ```
     * @param updateFunc - a function that updates the test result; the result is passed as a single argument and should be mutated to apply the changes
     * @param uuid - test result uuid
     */
    updateTest: (updateFunc: (result: TestResult) => void, uuid?: string) => void;
    stopTest: ({ uuid, stop }?: StopOpts) => void;
    /**
     * Writes a test result on disk and removes it from the storage and the context.
     * @param uuid The UUID of the test. If not set, the current test result is written.
     */
    writeTest: (uuid?: string) => void;
    /**
     * Starts a new step and pushes it into the context.
     *
     * @param result Data to be put into the step result object.
     * @param uuid The UUID of a test or fixture to attach the step to. If not set, the UUID of the current fixture is used.
     * If no fixture is running, the UUID of the current test is used.
     *
     * @returns The UUID of the step.
     */
    startStep: (result: Partial<StepResult>, uuid?: string) => `${string}-${string}-${string}-${string}-${string}` | undefined;
    updateStep: (updateFunc: (stepResult: StepResult) => void, uuid?: string) => void;
    stopStep: ({ uuid, stop }?: StopOpts) => void;
    writeAttachment: (attachmentName: string, attachmentContent: Buffer, options: AttachmentOptions, uuid?: string) => void;
    writeAttachmentFromPath: (attachmentName: string, attachmentPath: string, options: AttachmentOptions, uuid?: string) => void;
    writeEnvironmentInfo: () => void;
    writeCategoriesDefinitions: () => void;
    applyRuntimeMessages: <T>(messages?: Messages<T>[], { testUuid, fixtureUuid, customHandler }?: ApplyMessagesOpts<T>) => void;
    protected createTestResult(result: Partial<TestResult>): TestResult;
    private handleBuiltInMessage;
    private handleMetadataMessage;
    private handleStepStartMessage;
    private handleStepMetadataMessage;
    private handleStepStopMessage;
    private handleAttachmentContentMessage;
    private handleAttachmentPathMessage;
    private writeAttachmentForItem;
    private startScopeWithUuid;
    private resolveScope;
    private removeScopeFromParent;
    private removeFixtureFromScope;
    private setUpFixtureDedicatedScope;
    private linkScopes;
    private linkFixturesToScope;
    private linkFixtureToScope;
    private stopFixtureObj;
    private writeAllFixturesOfScope;
    private writeFixturesOfScope;
    private writeContainer;
    private addStepToItem;
    private logMissingStepRoot;
    private formatLinks;
    private introduceTestIntoScopes;
    private linkTestsToScope;
}
export {};
