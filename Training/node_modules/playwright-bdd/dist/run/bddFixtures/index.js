"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.test = void 0;
const test_1 = require("@playwright/test");
const loadConfig_1 = require("../../cucumber/loadConfig");
const loadSteps_1 = require("../../cucumber/loadSteps");
const bddWorld_1 = require("../bddWorld");
const config_1 = require("../../config");
const env_1 = require("../../config/env");
const steps_1 = require("../../steps/decorators/steps");
const configDir_1 = require("../../config/configDir");
const scenario_1 = require("../../hooks/scenario");
const worker_1 = require("../../hooks/worker");
const StepInvoker_1 = require("../StepInvoker");
const testMeta_1 = require("../../gen/testMeta");
const logger_1 = require("../../utils/logger");
const enrichReporterData_1 = require("../../config/enrichReporterData");
const bddData_1 = require("../bddData");
const loadStepsOwn_1 = require("../../cucumber/loadStepsOwn");
const specialTags_1 = require("../../specialTags");
const cucumberStyle_1 = require("../../steps/cucumberStyle");
// BDD fixtures prefixed with '$' to avoid collision with user's fixtures.
exports.test = test_1.test.extend({
    // load cucumber once per worker (auto-fixture)
    // todo: maybe remove caching in cucumber/loadConfig.ts and cucumber/loadSteps.ts
    // as we call it once per worker. Check generation phase.
    $cucumber: [
        async ({}, use, workerInfo) => {
            const config = (0, env_1.getConfigFromEnv)(workerInfo.project.testDir);
            const environment = { cwd: (0, configDir_1.getPlaywrightConfigDir)() };
            const { runConfiguration } = await (0, loadConfig_1.loadConfig)({
                provided: (0, config_1.extractCucumberConfig)(config),
            }, environment);
            const supportCodeLibrary = config.steps
                ? await (0, loadStepsOwn_1.loadStepsOwn)(environment.cwd, config.steps)
                : await (0, loadSteps_1.loadSteps)(runConfiguration, environment);
            (0, steps_1.appendDecoratorSteps)(supportCodeLibrary);
            (0, cucumberStyle_1.appendNewCucumberStyleSteps)(supportCodeLibrary);
            const World = (0, bddWorld_1.getWorldConstructor)(supportCodeLibrary);
            await use({ runConfiguration, supportCodeLibrary, World, config });
        },
        { auto: true, scope: 'worker' },
    ],
    // apply timeout and slow from special tags in runtime instead of generating in test body
    // to have cleaner test body and track fixtures in timeout calculation.
    $applySpecialTags: [
        async ({ $testMeta }, use, testInfo) => {
            const specialTags = new specialTags_1.SpecialTags($testMeta.ownTags, $testMeta.tags);
            if (specialTags.timeout !== undefined)
                testInfo.setTimeout(specialTags.timeout);
            if (specialTags.slow !== undefined)
                testInfo.slow();
            await use();
        },
        { auto: true },
    ],
    // $lang fixture can be overwritten in test file
    $lang: ({}, use) => use(''),
    // init $bddWorldFixtures with empty object, will be owerwritten in test file for cucumber-style
    $bddWorldFixtures: ({}, use) => use({}),
    $bddWorld: async ({ $tags, $test, $step, $bddWorldFixtures, $cucumber, $lang, $testMeta, $uri, $newCucumberStyleWorld, }, use, testInfo) => {
        const { runConfiguration, supportCodeLibrary, World, config } = $cucumber;
        const world = new World({
            testInfo,
            supportCodeLibrary,
            $tags,
            $test,
            $step,
            $bddWorldFixtures,
            lang: $lang,
            parameters: runConfiguration.runtime.worldParameters || {},
            log: () => logger_1.logger.warn(`world.log() is noop, please use world.testInfo.attach()`),
            attach: async () => logger_1.logger.warn(`world.attach() is noop, please use world.testInfo.attach()`),
        });
        if ((0, enrichReporterData_1.getEnrichReporterData)(config)) {
            world.$internal.bddDataManager = new bddData_1.BddDataManager(testInfo, $testMeta, $uri);
        }
        world.$internal.newCucumberStyleWorld = $newCucumberStyleWorld;
        await world.init();
        await use(world);
        await world.destroy();
    },
    Given: ({ $bddWorld }, use) => use(new StepInvoker_1.StepInvoker($bddWorld, 'Given').invoke),
    When: ({ $bddWorld }, use) => use(new StepInvoker_1.StepInvoker($bddWorld, 'When').invoke),
    Then: ({ $bddWorld }, use) => use(new StepInvoker_1.StepInvoker($bddWorld, 'Then').invoke),
    And: ({ $bddWorld }, use) => use(new StepInvoker_1.StepInvoker($bddWorld, 'And').invoke),
    But: ({ $bddWorld }, use) => use(new StepInvoker_1.StepInvoker($bddWorld, 'But').invoke),
    // new Cucumber style world, can be overwritten in test files
    $newCucumberStyleWorld: ({}, use) => use(null),
    // init $testMetaMap with empty object, will be overwritten in each test file
    $testMetaMap: ({}, use) => use({}),
    // concrete test meta
    $testMeta: ({ $testMetaMap }, use, testInfo) => use((0, testMeta_1.getTestMeta)($testMetaMap, testInfo)),
    // concrete test tags
    $tags: ({ $testMeta }, use) => use($testMeta.tags || []),
    // init $test with base test, but it will be overwritten in test file
    $test: ({}, use) => use(test_1.test),
    $step: ({}, use) => use({ title: '' }),
    // feature file uri, relative to configDir, will be overwritten in test file
    $uri: ({}, use) => use(''),
    // can be owerwritten in test file if there are scenario hooks
    $scenarioHookFixtures: ({}, use) => use({}),
    $before: [
        // Unused dependencies are important:
        // 1. $beforeAll / $afterAll: in pw < 1.39 worker-scoped auto-fixtures were called after test-scoped
        // 2. $after: to call after hooks in case of errors in before hooks
        async (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        { $scenarioHookFixtures, $bddWorld, $tags, $beforeAll, $afterAll, $after }, use, $testInfo) => {
            await (0, scenario_1.runScenarioHooks)('before', { $bddWorld, $tags, $testInfo, ...$scenarioHookFixtures });
            await use();
        },
        { auto: true },
    ],
    $after: [
        async ({ $scenarioHookFixtures, $bddWorld, $tags }, use, $testInfo) => {
            await use();
            await (0, scenario_1.runScenarioHooks)('after', { $bddWorld, $tags, $testInfo, ...$scenarioHookFixtures });
        },
        { auto: true },
    ],
    // can be owerwritten in test file if there are worker hooks
    $workerHookFixtures: [({}, use) => use({}), { scope: 'worker' }],
    $beforeAll: [
        // Important unused dependencies:
        // 1. $afterAll: in pw < 1.39 worker-scoped auto-fixtures are called in incorrect order
        // 2. $cucumber: to load hooks before this fixtures
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async ({ $workerHookFixtures, $cucumber }, use, $workerInfo) => {
            await (0, worker_1.runWorkerHooks)('beforeAll', { $workerInfo, ...$workerHookFixtures });
            await use();
        },
        { auto: true, scope: 'worker' },
    ],
    $afterAll: [
        async ({ $workerHookFixtures }, use, $workerInfo) => {
            await use();
            await (0, worker_1.runWorkerHooks)('afterAll', { $workerInfo, ...$workerHookFixtures });
        },
        { auto: true, scope: 'worker' },
    ],
});
//# sourceMappingURL=index.js.map